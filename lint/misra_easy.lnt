/**  The following list of MISRA rules are a cut-n-paste from the 
 * source lint makefiles, with the following changes
 *
 * +edddd changed to -edddd
 * +elib(dddd) changed for -elib(dddd)
 *
 * This will disable the rules enabled by the chosen MISRA profile(s).
 *
 * au-misra3.lnt
 * au-misra-cpp.lnt
 *
 * Additional commands / adjustments
 * were not touched as the rules reporting said lint message are disabled.
 *
**/

/*  Non-MISRA Rule Exceptions           */
    /* 526 - symbol __symbol__ is not defined */
    -e526
    -elib(526)
    
    /* 537 - repeated include file 'file' */
    -e537
    -elib(537)
    
    /* 641 - implicit conversion of enum __symbol__ to integral type __type__ */
    -e641
    -elib(641)
    
    /* 1502 - defined object __symbol__ of type __symbol__ has no non-static data members */
    -e1502
    -elib(1502)
    
    /* 1551 - function __symbol__ called outside of a try block in destructor __symbol__ is not declared as never throwing */
    -e1551
    -elib(1551)
    
    /* 1540 - non-static pointer data member __symbol__ not deallocated nor zeroed by destructor __symbol__
    TEMPORARY SUPPRESSION - Pending DEVOPS-63 Investigation */
    -e1540
    -elib(1540)
        
/*  MISRA Rule Exceptions               */

/* MISRA 2012 Directive 4.10, required */

    -e451             /* Header repeatedly included without guard */
    -elib(451)

/*  MISRA 2012 Directive 4.5, advisory  */

    -fta            /* enable typographical ambiguity checking */
    -e9046	  	    /* typographical ambiguity */
    -elib(9046)


/*  MISRA 2012 Directive 4.6, advisory  */

    -e970               /* flag modifiers used outside of typedefs */
    -elib(970)

/*  MISRA 2012 Directive 4.7, required  */

    -e534               /* ignoring return value of function */
    -elib(534)

/*  MISRA 2012 Directive 4.8, advisory  */

    -e9045               /* non-hidden definition of type */
    -elib(9045)

/*  MISRA 2012 Directive 4.9, advisory  */

    -e9026               /* function-like macro defined */
    -elib(9026)

/*  MISRA 2012 Rule 1.3, required       */

/*  MISRA 2012 Rule 2.1, required       */
    -e506                /* constant value used in Boolean context (string) */
    -elib(506)

/*  MISRA 2012 Rule 2.2, required       */

    -e438       /* value not used */
    -elib(438)

    -e505       /* redundant argument to comma */
    -elib(505)

    -e520       /* highest operator has no side effects */
    -elib(520)

    -e521       /* highest operator has no side effects */
    -elib(521)

    -e522       /* highest operator has no side effects */
    -elib(522)

    -e774       /* condition always evaluates to true/false */
    -elib(774)


/*  MISRA 2012 Rule 2.4, advisory       */

    -e753	   /* local tag not referenced */
    -elib(753)
    -e9058
    -elibsym(9058)

/*  MISRA 2012 Rule 2.5, advisory       */

    -e750	   /* local macro not referenced */
    -elib(750)
    -append(750,[MISRA 2012 Rule 2.5, advisory])
    -e755	   /* global macro not referenced */
    -elib(755)
    -append(755,[MISRA 2012 Rule 2.5, advisory])

/*  MISRA 2012 Rule 2.7, advisory       */

    -e715      	     /* not referenced */
    -elib(715)
    -append(715,[MISRA 2012 Rule 2.7, advisory])

/*  MISRA 2012 Rule 3.1, required       */

    -fnc                   /* flag nested comments */
    -e602                  /* comment within comment */
    -elib(602)

    -e9059
    -elib(9059)

    -e9066
    -elib(9066)

    -e9259
    -elib(9259)


/*  MISRA 2012 Rule 5.4, required       */

    -e547               /* conflicting macro definition */
    -elib(547)
    -append(547,[MISRA 2012 Rule 5.4, required])

    -e760               /* macro redefined identically */
    -elib(760)
    -append(760,[MISRA 2012 Rule 5.4, required])

    -e621                /* identifier clash */
    -elib(621)
    -append(621("macro vs macro"), [MISRA 2012 Rule 5.4, required])
    -append(621("macro vs macro parameter"), [MISRA 2012 Rule 5.4, required])
    -append(621("macro parameter vs macro parameter"), [MISRA 2012 Rule 5.4, required])


/*  MISRA 2012 Rule 5.5, required       */

    /* 9095 - symbol has same name as previously defined macro */
    -e9095
    -elib(9095)
    -append(9095,[MISRA 2012 Rule 5.5, required])

    /* 9096 - symbol has same name as subsequently defined macro */
    -e9096
    -elib(9096)
    -append(9096,[MISRA 2012 Rule 5.5, required])


/*  MISRA 2012 Rule 7.2, required       */

    -e9048                              /* unsigned literal without 'U' suffix */
    -elib(9048)
    -append(9048,[MISRA 2012 Rule 7.2, required])


/*  MISRA 2012 Rule 7.3, required       */

    -e620                           /* suspicious constant */
    -elib(620)
    -append(620,[MISRA 2012 Rule 7.3, required])
    -e9057                          /* "l" after "u" in literal suffix */
    -elib(9057)
    -append(9057,[MISRA 2012 Rule 7.3, required])


/*  MISRA 2012 Rule 7.4, required       */

   +fsc
    -e489                           /* attempting to modify a string literal */
    -elib(489)
    -append(489,[MISRA 2012 Rule 7.4, required])
    -e1776                          /* string literal not const safe */
    -elib(1776)
    -append(1776,[MISRA 2012 Rule 7.4, required])
    -e1778                          /* assignment of string literal not const safe */
    -elib(1778)
    -append(1778,[MISRA 2012 Rule 7.4, required])


/*  MISRA 2012 Rule 8.2, required       */

   -e937                     /* old-style function declaration */
    -elib(937)
    -append(937,[MISRA 2012 Rule 8.2, required])
    -e18                          /* symbol redeclared */
    -elib(18)
    -append(18,[MISRA 2012 Rule 8.2, required])

    -e936                         /* old-style function definition */
    -elib(936)
    -append(936,[MISRA 2012 Rule 8.2, required])

    -e955                         /* param name missing from prototype */
    -elib(955)
    -append(955,[MISRA 2012 Rule 8.2, required])


/*  MISRA 2012 Rule 8.3, required       */

    -e18                          /* symbol redeclared */
    -elib(18)
    -append(18,[MISRA 2012 Rule 8.3, required])

    /* 9072 parameter has different name than previous declaration  */
    -e9072
    -elib(9072)
    -append(9072,[MISRA 2012 Rule 8.3, required])

    /* 9073 parameter has type alias name type difference with previous
            declaration */
    -e9073
    -elib(9073)
    -append(9073,[MISRA 2012 Rule 8.3, required])

    /* 9094 return type has type alias name difference with previous
            declaration */
    -e9094
    -elib(9094)
    -append(9094,[MISRA 2012 Rule 8.3, required])


/*  MISRA 2012 Rule 8.5, required       */

    -e9004        /* object/function previously declared */
    -elib(9004)
    -append(9004,[MISRA 2012 Rule 8.5, required])


/*  MISRA 2012 Rule 8.7, advisory       */

    -e765        /* could be made static */
    -elib(765)
    -append(765,[MISRA 2012 Rule 8.7, advisory])


/*  MISRA 2012 Rule 8.9, advisory       */

    -e9003        /* could define variable at block scope */
    -elib(9003)
    -append(9003,[MISRA 2012 Rule 8.9, advisory])

/*  MISRA 2012 Rule 8.10, required      */

    -e695    	     /* inline function without storage-class specifier */
    -elib(695)
    -append(695,[MISRA 2012 Rule 8.10, required])
    -estring(9056,extern)     /* inline function defined with extern */
    -append(9056,[MISRA 2012 Rule 8.10, required])



/*  MISRA 2012 Rule 8.11, advisory      */

    -e9067             /* array has no dimension or initializer */
    -elib(9067)
    -append(9067,[MISRA 2012 Rule 8.11, advisory])

/*  MISRA 2012 Rule 8.13, advisory      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e818	/* pointer could be declared pointing to const */
    -elib(818)
    -append(818,[MISRA 2012 Rule 8.13, advisory])
    -e844	/* pointer could be declared pointing to const */
    -elib(844)
    -append(844,[MISRA 2012 Rule 8.13, advisory])
    -e954	/* pointer could be declared pointing to const */
    -elib(954)
    -append(954,[MISRA 2012 Rule 8.13, advisory])

    -fcv /* report parameters even if exclusively cast to void */



/*  MISRA 2012 Rule 9.3, required       */

    -e9068                  /* too few initializers */
    -elib(9068)
    -append(9068,[MISRA 2012 Rule 9.3, required])

/*  MISRA 2012 Rule 10.1, required      */

    -e48				/* bad type */
    -elib(48)
    -append(48,[MISRA 2012 Rule 10.1, required])
    -e9027                              /* unpermitted operand */
    -elib(9027)
    -append(9027,[MISRA 2012 Rule 10.1, required])

/*  MISRA 2012 Rule 10.3, required      */

    -e9034                              /* expression assigned to narrower or different essential type */
    -elib(9034)
    -estring(9052, true, false)
    -append(9034,[MISRA 2012 Rule 10.3, required])


/*  MISRA 2012 Rule 10.4, required      */

    -e9029                              /* mismatched essential type */
    -elib(9029)
    -append(9029,[MISRA 2012 Rule 10.4, required])

/*  MISRA 2012 Rule 10.6, required      */

    -e9031                              /* composite expression assigned to wider essential type */
    -elib(9031)
    -append(9031,[MISRA 2012 Rule 10.6, required])


/*  MISRA 2012 Rule 11.1, required      */

    /* 176 - cannot cast non-pointer non-integer to function pointer */
    -e176
    -elib(176)
    -append(176,[MISRA 2012 Rule 11.1, required])

    /* 178 - cannot cast function pointer to non-pointer non-integer */
    -e178
    -elib(178)
    -append(178,[MISRA 2012 Rule 11.1, required])

    -e9074                   /* conversion between a pointer to function and another type */
    -elib(9074)
    -append(9074,[MISRA 2012 Rule 11.1, required])

/*  MISRA 2012 Rule 11.2, required      */

    -e9076                   /* conversion between a pointer to incomplete type and another type */
    -elib(9076)
    -append(9076,[MISRA 2012 Rule 11.2, required])


/*  MISRA 2012 Rule 11.3, required      */

    -e9087         /* cast from pointer to pointer */
    -elib(9087)
    -append(9087,[MISRA 2012 Rule 11.3, required])

/*  MISRA 2012 Rule 11.4, advisory      */
    -e9078                        /* cast pointer/integer */
    -elib(9078)
    -append(9078,[MISRA 2012 Rule 11.4, advisory])

/*  MISRA 2012 Rule 11.5, advisory      */

    -e9079         /* cast from pointer to pointer */
    -elib(9079)
    -append(9079,[MISRA 2012 Rule 11.5, advisory])

/*  MISRA 2012 Rule 11.6, required      */

    -elib(923)     /* cast pointer/non-pointer */
    -etype(923, void *)
    -append(923,[MISRA 2012 Rule 11.6, required])

/*  MISRA 2012 Rule 11.8, required      */

    -e9005                              /* attempt to cast away const/volatile from pointer or reference */
    -elib(9005)
    -append(9005,[MISRA 2012 Rule 11.8, required])


/*  MISRA 2012 Rule 11.9, required      */

    -e9080      /* integer null pointer constant */
    -elib(9080)
    -append(9080,[MISRA 2012 Rule 11.9, required])


/*  MISRA 2012 Rule 12.1, advisory      */

    -e9050        /* dependence placed on precedence */
    -elib(9050)
    -append(9050,[MISRA 2012 Rule 12.1, advisory])

    -e9097        /* unparenthesized argument to sizeof */
    -elib(9097)
    -append(9097,[MISRA 2012 Rule 12.1, advisory])



/*  MISRA 2012 Rule 12.2, required      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e598           /* excessive left shift */
    -elib(598)
    -append(598,[MISRA 2012 Rule 12.2, required])
    -e9053          /* shift value exceeds size of LHS */
    -elib(9053)
    -append(9053,[MISRA 2012 Rule 12.2, required])


/*  MISRA 2012 Rule 12.3, advisory      */

    -e9008                              /* comma operator used */
    -elib(9008)
    -append(9008,[MISRA 2012 Rule 12.3, advisory])

/*  MISRA 2012 Rule 13.1, required      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e446                              /* side effect in initializer */
    -elib(446)
    -append(446,[MISRA 2012 Rule 13.1, required])



/*  MISRA 2012 Rule 13.2, required      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e564			/* variable depends on order of evaluation */
    -elib(564)
    -append(564,[MISRA 2012 Rule 13.2, required])
	
/*  MISRA 2012 Rule 13.3, advisory      */

    -e9049                              /* increment/decrement combined with other operations */
    -elib(9049)
    -append(9049,[MISRA 2012 Rule 13.3, advisory])

/*  MISRA 2012 Rule 13.4, advisory      */

    -e720                    /* Boolean test of assignment */
    -elib(720)
    -append(720,[MISRA 2012 Rule 13.4, advisory])
    -e820                    /* Boolean test of parenthesized assignment */
    -elib(820)
    -append(820,[MISRA 2012 Rule 13.4, advisory])
    -e9084                   /* assignment used inside larger
                                expression */
    -elib(9084)
    -append(9084,[MISRA 2012 Rule 13.4, advisory])
	
/*  MISRA 2012 Rule 13.5, required      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e9007                              /* side effects on right hand side of logical operator */
    -elib(9007)
    -append(9007,[MISRA 2012 Rule 13.5, required])

/*  MISRA 2012 Rule 13.6, mandatory     */


    -e9006                              /* sizeof used with expression with side effect */
    -elib(9006)
    -append(9006,[MISRA 2012 Rule 13.6, mandatory])
    -e9089                              /* potential side-effect in argument to sizeof */
    -elib(9089)
    -append(9089,[MISRA 2012 Rule 13.6, mandatory])
	
/*  MISRA 2012 Rule 14.1, required      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e9009                              /* floating point variable used as loop counter */
    -elib(9009)
    -append(9009,[MISRA 2012 Rule 14.1, required])
	
/*  MISRA 2012 Rule 14.4, required      */


    -e9036                              /* condition should have essentially Boolean type */
    -elib(9036)
    -append(9036,[MISRA 2012 Rule 14.4, required])
	
	
/*  MISRA 2012 Rule 15.4, advisory      */


    -e9011                              /* more than one 'break' terminates loop */
    -elib(9011)
    -append(9011,[MISRA 2012 Rule 15.4, advisory])
	
	
/*  MISRA 2012 Rule 15.5, advisory      */

    -e904                   /* return before function end */
    -elib(904)
    -append(904,[MISRA 2012 Rule 15.5, advisory])
	
	
/*  MISRA 2012 Rule 15.6, required      */

    -e9012                   /* sub-statement should be a compound statement */
    -elib(9012)
    -append(9012,[MISRA 2012 Rule 15.6, required])
	
	
/*  MISRA 2012 Rule 15.7, required      */


    -e9013                   /* no 'else' at end of 'if ... else if' chain */
    -elib(9013)
    -append(9013,[MISRA 2012 Rule 15.7, required])
    -e9063                   /* no comment or action in else-branch */
    -elib(9063)
    -append(9063,[MISRA 2012 Rule 15.7, required])
	
	
/*  MISRA 2012 Rule 16.1, required      */

    -e616                  /* control flows into case/default */
    -elib(616)
    -append(616,[MISRA 2012 Rule 16.1, required])
    -e744                  /* switch statement has no default */
    -elib(744)
    -append(744,[MISRA 2012 Rule 16.1, required])
    -e764                  /* switch does not have a case */
    -elib(764)
    -append(764,[MISRA 2012 Rule 16.1, required])
    -e825                  /* control flows into case/default without -fallthrough comment */
    -elib(825)
    -append(825,[MISRA 2012 Rule 16.1, required])
    -e9014                 /* default missing from switch */
    -elib(9014)
    -append(9014,[MISRA 2012 Rule 16.1, required])
    -e9042                 /* departure from MISRA switch syntax */
    -elib(9042)
    -append(9042,[MISRA 2012 Rule 16.1, required])
    -e9077                 /* missing unconditional break */
    -elib(9077)
    -append(9077,[MISRA 2012 Rule 16.1, required])
    -e9081                 /* too few independent cases for switch */
    -elib(9081)
    -append(9081,[MISRA 2012 Rule 16.1, required])
    -e9082                 /* switch statement should either begin or end with default label */
    -elib(9082)
    -append(9082,[MISRA 2012 Rule 16.1, required])
    -e9085                 /* statement or comment should appear in default case */
    -elib(9085)
    -append(9085,[MISRA 2012 Rule 16.1, required])


/*  MISRA 2012 Rule 16.3, required      */


    -e616                 /* control flows into case/default */
    -elib(616)
    -append(616,[MISRA 2012 Rule 16.3, required])
    -e825                 /* control flows into case/default without -fallthrough comment */
    -elib(825)
    -append(825,[MISRA 2012 Rule 16.3, required])
    -e9077                /* missing unconditional break */
    -elib(9077)
    -append(9077,[MISRA 2012 Rule 16.3, required])
    -e9090                /* missing unconditional break */
    -elib(9090)
    -append(9090,[MISRA 2012 Rule 16.3, required])
	
	
/*  MISRA 2012 Rule 16.4, required      */


    -e744            /* switch statement has no default */
    -elib(744)
    -append(744,[MISRA 2012 Rule 16.4, required])
    -e9014            /* switch statement has no default */
    -elib(9014)
    -append(9014,[MISRA 2012 Rule 16.4, required])
    -e9085            /* default case has no statement nor comment */
    -elib(9085)
    -append(9085,[MISRA 2012 Rule 16.4, required])
	
	
/*  MISRA 2012 Rule 16.5, required      */


    -e9082                   /* default should be first or last */
    -elib(9082)
    -append(9082,[MISRA 2012 Rule 16.5, required])
	
	
/*  MISRA 2012 Rule 16.6, required      */


    -e764            /* switch does not have a case */
    -elib(764)
    -append(764,[MISRA 2012 Rule 16.6, required])
    -e9081           /* too few cases */
    -elib(9081)
    -append(9081,[MISRA 2012 Rule 16.6, required])
	
	
/*  MISRA 2012 Rule 17.1, required      */


    -e829       /* warn on header usage */
    -elib(829)
    +headerwarn(stdarg.h)
    -append(829(stdarg.h),[MISRA 2012 Rule 17.1, required])
    -deprecate(macro,va_arg,[MISRA 2012 Rule 17.1, required])
    -deprecate(macro,va_start,[MISRA 2012 Rule 17.1, required])
    -deprecate(macro,va_end,[MISRA 2012 Rule 17.1, required])
    -deprecate(macro,va_copy,[MISRA 2012 Rule 17.1, required])
    -deprecate(type,va_list,[MISRA 2012 Rule 17.1, required])
	
	
/*  MISRA 2012 Rule 17.7, required      */


    -e534               /* ignoring return value of function */
    -elib(534)
    -append(534,[MISRA 2012 Rule 17.7, required])
	
	
/*  MISRA 2012 Rule 17.8, advisory      */

    /* While MISRA has declared this rule to be "undecidable", Gimpel
     * Software provides the following options to assist:
     */
    -e9044               /* function parameter modified */
    -elib(9044)
    -append(9044,[MISRA 2012 Rule 17.8, advisory])
	
	
/*  MISRA 2012 Rule 18.4, advisory      */


    -e9016                   /* pointer arithmetic other than array indexing used */
    -elib(9016)
    -append(9016,[MISRA 2012 Rule 18.4, advisory])
	
	
/*  MISRA 2012 Rule 19.2, advisory      */


    -e9018                   /* union type/object declared */
    -elib(9018)
    -append(9018,[MISRA 2012 Rule 19.2, advisory])
	
	

/*  MISRA 2012 Rule 20.2, required      */

    -e9020                   /* header file name with non-standard character */
    -elib(9020)
    -append(9020,[MISRA 2012 Rule 20.2, required])
    /*  Note: If your system requires the '\' be used as a directory
        separator, uncomment the following option.
     */
    //  -estring(9020,\)
	
/*  MISRA 2012 Rule 20.4, required      */

    -e9051                              /* macro with same name as a keyword */
    -elib(9051)
    -append(9051,[MISRA 2012 Rule 20.4, required])
	
	
/*  MISRA 2012 Rule 20.5, advisory      */


    -e9021                   /* use of '#undef' is discouraged */
    -elib(9021)
    -append(9021,[MISRA 2012 Rule 20.5, advisory])
	
	
/*  MISRA 2012 Rule 20.7, required      */


    -e665                   /* expression passed to unparenthesized macro */
    -elib(665)
    -append(665,[MISRA 2012 Rule 20.7, required])
	
	
/*  MISRA 2012 Rule 20.9, required      */


    -e553   /* Undefined preprocessor variable, assumed 0 */
    -elib(553)
    -append(553,[MISRA 2012 Rule 20.9, required])
	
	
/*  MISRA 2012 Rule 20.10, advisory     */


    -e9024                   /* '#/##' operators used */
    -elib(9024)
    -append(9024,[MISRA 2012 Rule 20.10, advisory])
	
	
/*  MISRA 2012 Rule 20.13, required     */


    /* 544 - directive not followed by EOL */
    -e544
    -elib(544)
    -append(544,[MISRA 2012 Rule 20.13, required])

    /* 16 - unknown preprocessor directive */
    -e16
    -elib(16)
    -append(16,[MISRA 2012 Rule 20.13, required])

    /* 9160 - unknown preprocessor directive in conditionally excluded
            region */
    -e9160
    -elib(9160)
    -append(9160,[MISRA 2012 Rule 20.13, required])
	
	
/*  MISRA 2012 Rule 21.1, required      */


    -e136       /* Illegal macro name */
    -elib(136)
    -append(136,[MISRA 2012 Rule 21.1, required])
    /*  Undefining standard library macros is covered by rule 20.5.  */
    /*  Defining/redefining reserved/standard identifiers is covered
        by rules 20.4 and 21.2.
     */
    -e9071      /* defined macro reserved to the compiler */
    -elib(9071)
    -append(9071,[MISRA 2012 Rule 21.1, required])
    // explicit exemptions
    -estring(9071,* because *)
    -estring(9071,cerf)
    -estring(9071,cerfc)
    -estring(9071,cexp2)
    -estring(9071,cexpm1)
    -estring(9071,clog10)
    -estring(9071,clog1p)
    -estring(9071,clog2)
    -estring(9071,clgamma)
    -estring(9071,ctgamma)
    -estring(9071,cerff)
    -estring(9071,cerfcf)
    -estring(9071,cexp2f)
    -estring(9071,cexpm1f)
    -estring(9071,clog10f)
    -estring(9071,clog1pf)
    -estring(9071,clog2f)
    -estring(9071,clgammaf)
    -estring(9071,ctgammaf)
    -estring(9071,cerfl)
    -estring(9071,cerfcl)
    -estring(9071,cexp2l)
    -estring(9071,cexpm1l)
    -estring(9071,clog10l)
    -estring(9071,clog1pl)
    -estring(9071,clog2l)
    -estring(9071,clgammal)
    -estring(9071,ctgammal)
    -estring(9071,E0*)
    -estring(9071,E1*)
    -estring(9071,E2*)
    -estring(9071,E3*)
    -estring(9071,E4*)
    -estring(9071,E5*)
    -estring(9071,E6*)
    -estring(9071,E7*)
    -estring(9071,E8*)
    -estring(9071,E9*)
    -estring(9071,NDEBUG)
    -estring(9071,PRIa*)
    -estring(9071,PRIb*)
    -estring(9071,PRIc*)
    -estring(9071,PRId*)
    -estring(9071,PRIe*)
    -estring(9071,PRIf*)
    -estring(9071,PRIg*)
    -estring(9071,PRIh*)
    -estring(9071,PRIi*)
    -estring(9071,PRIj*)
    -estring(9071,PRIk*)
    -estring(9071,PRIl*)
    -estring(9071,PRIm*)
    -estring(9071,PRIn*)
    -estring(9071,PRIo*)
    -estring(9071,PRIp*)
    -estring(9071,PRIq*)
    -estring(9071,PRIr*)
    -estring(9071,PRIs*)
    -estring(9071,PRIt*)
    -estring(9071,PRIu*)
    -estring(9071,PRIv*)
    -estring(9071,PRIw*)
    -estring(9071,PRIx*)
    -estring(9071,PRIy*)
    -estring(9071,PRIz*)
    -estring(9071,PRIX*)
    -estring(9071,SCNa*)
    -estring(9071,SCNb*)
    -estring(9071,SCNc*)
    -estring(9071,SCNd*)
    -estring(9071,SCNe*)
    -estring(9071,SCNf*)
    -estring(9071,SCNg*)
    -estring(9071,SCNh*)
    -estring(9071,SCNi*)
    -estring(9071,SCNj*)
    -estring(9071,SCNk*)
    -estring(9071,SCNl*)
    -estring(9071,SCNm*)
    -estring(9071,SCNn*)
    -estring(9071,SCNo*)
    -estring(9071,SCNp*)
    -estring(9071,SCNq*)
    -estring(9071,SCNr*)
    -estring(9071,SCNs*)
    -estring(9071,SCNt*)
    -estring(9071,SCNu*)
    -estring(9071,SCNv*)
    -estring(9071,SCNw*)
    -estring(9071,SCNx*)
    -estring(9071,SCNy*)
    -estring(9071,SCNz*)
    -estring(9071,SCNX*)
    -e9083      /* undefined macro reserved to the compiler */
    -elib(9083)
    -append(9083,[MISRA 2012 Rule 21.1, required])
    // explicit exemptions
    -estring(9083,* because *)
    -estring(9083,cerf)
    -estring(9083,cerfc)
    -estring(9083,cexp2)
    -estring(9083,cexpm1)
    -estring(9083,clog10)
    -estring(9083,clog1p)
    -estring(9083,clog2)
    -estring(9083,clgamma)
    -estring(9083,ctgamma)
    -estring(9083,cerff)
    -estring(9083,cerfcf)
    -estring(9083,cexp2f)
    -estring(9083,cexpm1f)
    -estring(9083,clog10f)
    -estring(9083,clog1pf)
    -estring(9083,clog2f)
    -estring(9083,clgammaf)
    -estring(9083,ctgammaf)
    -estring(9083,cerfl)
    -estring(9083,cerfcl)
    -estring(9083,cexp2l)
    -estring(9083,cexpm1l)
    -estring(9083,clog10l)
    -estring(9083,clog1pl)
    -estring(9083,clog2l)
    -estring(9083,clgammal)
    -estring(9083,ctgammal)
    -estring(9083,E0*)
    -estring(9083,E1*)
    -estring(9083,E2*)
    -estring(9083,E3*)
    -estring(9083,E4*)
    -estring(9083,E5*)
    -estring(9083,E6*)
    -estring(9083,E7*)
    -estring(9083,E8*)
    -estring(9083,E9*)
    -estring(9083,NDEBUG)
    -estring(9083,PRIa*)
    -estring(9083,PRIb*)
    -estring(9083,PRIc*)
    -estring(9083,PRId*)
    -estring(9083,PRIe*)
    -estring(9083,PRIf*)
    -estring(9083,PRIg*)
    -estring(9083,PRIh*)
    -estring(9083,PRIi*)
    -estring(9083,PRIj*)
    -estring(9083,PRIk*)
    -estring(9083,PRIl*)
    -estring(9083,PRIm*)
    -estring(9083,PRIn*)
    -estring(9083,PRIo*)
    -estring(9083,PRIp*)
    -estring(9083,PRIq*)
    -estring(9083,PRIr*)
    -estring(9083,PRIs*)
    -estring(9083,PRIt*)
    -estring(9083,PRIu*)
    -estring(9083,PRIv*)
    -estring(9083,PRIw*)
    -estring(9083,PRIx*)
    -estring(9083,PRIy*)
    -estring(9083,PRIz*)
    -estring(9083,PRIX*)
    -estring(9083,SCNa*)
    -estring(9083,SCNb*)
    -estring(9083,SCNc*)
    -estring(9083,SCNd*)
    -estring(9083,SCNe*)
    -estring(9083,SCNf*)
    -estring(9083,SCNg*)
    -estring(9083,SCNh*)
    -estring(9083,SCNi*)
    -estring(9083,SCNj*)
    -estring(9083,SCNk*)
    -estring(9083,SCNl*)
    -estring(9083,SCNm*)
    -estring(9083,SCNn*)
    -estring(9083,SCNo*)
    -estring(9083,SCNp*)
    -estring(9083,SCNq*)
    -estring(9083,SCNr*)
    -estring(9083,SCNs*)
    -estring(9083,SCNt*)
    -estring(9083,SCNu*)
    -estring(9083,SCNv*)
    -estring(9083,SCNw*)
    -estring(9083,SCNx*)
    -estring(9083,SCNy*)
    -estring(9083,SCNz*)
    -estring(9083,SCNX*)
	
	
/*  MISRA 2012 Rule 21.5, required      */

    -e586       /* Symbol is deprecated */
    -elib(586)
    -deprecate(function,signal,[MISRA 2012 Rule 21.5, required])
    -deprecate(function,raise,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIGABRT,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIGFPE,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIGILL,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIGINT,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIGSEGV,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIGTERM,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIG_DFL,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIG_ERR,[MISRA 2012 Rule 21.5, required])
    -deprecate(macro,SIG_IGN,[MISRA 2012 Rule 21.5, required])
    -deprecate(type,sig_atomic_t,[MISRA 2012 Rule 21.5, required])
    -e829       /* warn on header usage */
    -elib(829)
    +headerwarn(signal.h)
    -append(829(signal.h),[MISRA 2012 Rule 21.5, required])
	
/*  MISRA 2012 Rule 21.10, required     */


    -e586       /* Symbol is deprecated */
    -elib(586)
    -deprecate(macro,wcsftime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,wcsftime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,clock,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,clock,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,difftime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,difftime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,mktime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,mktime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,time,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,time,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,asctime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,asctime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,ctime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,ctime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,gmtime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,gmtime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,localtime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,localtime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,strftime,[MISRA 2012 Rule 21.10, required])
    -deprecate(function,strftime,[MISRA 2012 Rule 21.10, required])
    -deprecate(macro,CLOCKS_PER_SEC,[MISRA 2012 Rule 21.10, required])
    -deprecate(type,clock_t,[MISRA 2012 Rule 21.10, required])
    -deprecate(type,time_t,[MISRA 2012 Rule 21.10, required])
    -deprecate(type,struct tm,[MISRA 2012 Rule 21.10, required])
    -e829       /* warn on header usage */
    -elib(829)
    +headerwarn(time.h)
    -append(829(time.h),[MISRA 2012 Rule 21.10, required])
	
	
/*  MISRA C++ Rule 0-1-1                */

    /* 527 - statement is unreachable due to unconditional transfer of control */
    -e527
    -elib(527)
    -append(527,[MISRA C++ Rule 0-1-1])

    /* 681 - loop is likely not entered */
    -e681
    -elib(681)
    -append(681,[MISRA C++ Rule 0-1-1])

    /* 827 - loop can only be reached via goto due to unconditional transfer of
            control */
    -e827
    -elib(827)
    -append(827,[MISRA C++ Rule 0-1-1])

    /* 685 - relational operator always evaluates to true/false */
    -e685
    -elib(685)
    -append(685,[MISRA C++ Rule 0-1-1])

    /* 774 - boolean condition always evaluates to true/false */
    -e774
    -elib(774)
    -append(774,[MISRA C++ Rule 0-1-1])

    /* 944 - left/right operand always evaluates to true/false */
    -e944
    -elib(944)
    -append(944,[MISRA C++ Rule 0-1-1])
	
/*  MISRA C++ Rule 0-1-2                */

    /* 685 - relational operator always evaluates to true/false */
    -e685
    -elib(685)
    -append(685,[MISRA C++ Rule 0-1-2])

    /* 774 - boolean condition always evaluates to true/false */
    -e774
    -elib(774)
    -append(774,[MISRA C++ Rule 0-1-2])

    /* 827 - loop can only be reached via goto due to unconditional transfer of
            control */
    -e827
    -elib(827)
    -append(827,[MISRA C++ Rule 0-1-2])

    /* 944 - left/right operand always evaluates to true/false */
    -e944
    -elib(944)
    -append(944,[MISRA C++ Rule 0-1-2])
	
	
/*  MISRA C++ Rule 0-1-3                */

    /* 528 - static symbol not referenced */
    -e528
    -elib(528)
    -append(528,[MISRA C++ Rule 0-1-3])

    /* 529 - local variable not subsequently referenced */
    -e529
    -elib(529)
    -append(529,[MISRA C++ Rule 0-1-3])

    /* 714 - external symbol was defined but not referenced */
    -e714
    -elib(714)
    -append(714,[MISRA C++ Rule 0-1-3])

    /* 752 - local declarator not referenced */
    -e752
    -elib(752)
    -append(752,[MISRA C++ Rule 0-1-3])

    /* 757 - global declarator not referenced */
    -e757
    -elib(757)
    -append(757,[MISRA C++ Rule 0-1-3])

    /* 1715 - static member symbol not referenced */
    -e1715
    -elib(1715)
    -append(1715,[MISRA C++ Rule 0-1-3])
	
	
/*  MISRA C++ Rule 0-1-4                */

    /* 528 - static symbol not referenced */
    -e528
    -elib(528)
    -append(528,[MISRA C++ Rule 0-1-4])

    /* 529 - local variable not subsequently referenced */
    -e529
    -elib(529)
    -append(529,[MISRA C++ Rule 0-1-4])

    /* 550 - local variable not subsequently accessed */
    -e550
    -elib(550)
    -append(550,[MISRA C++ Rule 0-1-4])

    /* 551 - static variable not accessed */
    -e551
    -elib(551)
    -append(551,[MISRA C++ Rule 0-1-4])

    /* 552 - external variable not accessed */
    -e552
    -elib(552)
    -append(552,[MISRA C++ Rule 0-1-4])
	
	
/*  MISRA C++ Rule 0-1-5                */

    /* 751 - local typedef not referenced */
    -e751
    -elib(751)
    -append(751,[MISRA C++ Rule 0-1-5])

    /* 753 - local tag not referenced */
    -e753
    -elib(753)
    -append(753,[MISRA C++ Rule 0-1-5])

    /* 756 - global typedef not referenced */
    -e756
    -elib(756)
    -append(756,[MISRA C++ Rule 0-1-5])

    /* 758 - global tag not referenced */
    -e758
    -elib(758)
    -append(758,[MISRA C++ Rule 0-1-5])
	
	
/*  MISRA C++ Rule 0-1-6                */

    /* 438 - last value assigned to symbol not used */
    -e438
    -elib(438)
    -append(438,[MISRA C++ Rule 0-1-6])

    /* 838 - previous value assigned to symbol not used */
    -e838
    -elib(838)
    -append(838,[MISRA C++ Rule 0-1-6])
	
	
/*  MISRA C++ Rule 0-1-7                */


    /* 534 - ignoring return value of function */
    -e534
    -elib(534)
    -append(534,[MISRA C++ Rule 0-1-7])



/*  MISRA C++ Rule 0-1-8                */


    /* 9175 - function has void return type and no external side-effects */
    -e9175
    -elib(9175)
    -append(9175,[MISRA C++ Rule 0-1-8])
	
	
/*  MISRA C++ Rule 0-1-9                */

    /* 438 - last value assigned to symbol not used */
    -e438
    -elib(438)
    -append(438,[MISRA C++ Rule 0-1-9])

    /* 587 - predicate can be pre-determined and always evaluates to true/false */
    -e587
    -elib(587)
    -append(587,[MISRA C++ Rule 0-1-9])

    /* 685 - relational operator always evaluates to true/false */
    -e685
    -elib(685)
    -append(685,[MISRA C++ Rule 0-1-9])

    /* 774 - boolean condition always evaluates to true/false */
    -e774
    -elib(774)
    -append(774,[MISRA C++ Rule 0-1-9])

    /* 838 - previous value assigned to symbol not used */
    -e838
    -elib(838)
    -append(838,[MISRA C++ Rule 0-1-9])

    /* 944 - left/right operand always evaluates to true/false */
    -e944
    -elib(944)
    -append(944,[MISRA C++ Rule 0-1-9])

    /* 948 - operator always evaluates to true/false */
    -e948
    -elib(948)
    -append(948,[MISRA C++ Rule 0-1-9])
	
	
/*  MISRA C++ Rule 0-1-10               */

    /* 528 - static symbol not referenced */
    -e528
    -elib(528)
    -append(528,[MISRA C++ Rule 0-1-10])

    /* 714 - external symbol was defined but not referenced */
    -e714
    -elib(714)
    -append(714,[MISRA C++ Rule 0-1-10])

    /*1714 - member function not referenced */
    -e1714
    -elib(1714)
    -append(1714,[MISRA C++ Rule 0-1-10])

    /* default constructor not referenced */
    -e1914
    -elib(1914)
    -append(1914,[MISRA C++ Rule 0-1-10])
	
	
/*  MISRA C++ Rule 0-1-11               */


    /* 715 - named parameter not subsequently referenced */
    -e715
    -elib(715)
    -append(715(non-virtual),[MISRA C++ Rule 0-1-11])

    /* 9215 - unnamed function parameter */
    -e9215
    -elib(9215)
    -append(9215(non-virtual),[MISRA C++ Rule 0-1-11])
	
	
/*  MISRA C++ Rule 0-3-2                */


    /* 534 - ignoring return value of function */
    -e534
    -elib(534)
    -append(534,[MISRA C++ Rule 0-3-2])
	
	
/*  MISRA C++ Rule 2-10-1               */

    /* 606 - non-ANSI escape sequence */
    -e606
    -elib(606)
    -append(606,[MISRA C++ Rule 2-13-1])


/*  MISRA C++ Rule 2-13-3               */

    /* 9105 - unsigned octal and hexadecimal literals require a 'U' suffix */
    -e9105
    -elib(9105)
    -append(9105,[MISRA C++ Rule 2-13-3])


/*  MISRA C++ Rule 2-13-4               */

    /* 9106 - lower case literal suffix */
    -e9106
    -elib(9106)
    -append(9106,[MISRA C++ Rule 2-13-4])
	
	
/*  MISRA C++ Rule 3-1-1                */

    /* 9107 - header cannot be included in more than one translation unit because
              of the definition of symbol */
    -e9107
    -elib(9107)
    -append(9107,[MISRA C++ Rule 3-1-1])
	
	
/*  MISRA C++ Rule 3-1-3                */


    /* 9067 - extern array declared without size or initializer */
    -e9067
    -elib(9067)
    -append(9067,[MISRA C++ Rule 3-1-3])
	
	
	
/*  MISRA C++ Rule 3-2-3                */


    /* 9004 - object/function previously declared */
    -e9004
    -elib(9004)
    -append(9004,[MISRA C++ Rule 3-2-3])
	
	
/*  MISRA C++ Rule 3-3-1                */


    /* 759 - header declaration for symbol could be moved from header to module */
    -e759
    -elib(759)
    -append(759,[MISRA C++ Rule 3-3-1])

    /* 765 - external symbol could be made static */
    -e765
    -elib(765)
    -append(765,[MISRA C++ Rule 3-3-1])
	
	
/*  MISRA C++ Rule 3-3-2                */


    /* 401 - not previously declared static */
    -e401
    -elib(401)
    -append(401,[MISRA C++ Rule 3-3-2])

    /* 839 - storage class of symbol assumed static */
    -e839
    -elib(839)
    -append(839,[MISRA C++ Rule 3-3-2])
	
	
/*  MISRA C++ Rule 3-4-1                */


    /* 9003 - could define global variable 'Symbol' within function */
    -e9003
    -elib(9003)
    -append(9003,[MISRA C++ Rule 3-4-1])
	
	
/*  MISRA C++ Rule 3-9-1                */


    /* 9073 - parameter 'Integer' of function 'Symbol' has type alias name
       difference with previous declaration ('Type' vs 'Type') */
    -e9073
    -elib(9073)
    -append(9073,[MISRA C++ Rule 3-9-1])

    /* 9094 - return type of function 'Symbol' has type alias name difference
       with previous declaration ('Type' vs 'Type') */
    -e9094
    -elib(9094)
    -append(9094,[MISRA C++ Rule 3-9-1])

    /* 9168 - variable has type alias name difference with previous
       declaration */
    -e9168
    -elib(9168)
    -append(9168,[MISRA C++ Rule 3-9-1])
	
	
/*  MISRA C++ Rule 3-9-2                */


    /* 970 - use of modifier or type outside of a typedef */
    -e970
    -elib(970)
    -esym(970,wchar_t)
    -append(970,[MISRA C++ Rule 3-9-2])
    //  For the duration, we are presuming MISRA does not want
    //  diagnostics for the bool type.
    -esym(970,bool)
	
	
	
/*  MISRA C++ Rule 4-10-2               */


    /* 910 - implicit conversion of null pointer constant to pointer */
    -e910
    -elib(910)
    -emacro(910, NULL)    /*  explicit exception  */
    -append(910,[MISRA C++ Rule 4-10-2])
	
	
/*  MISRA C++ Rule 4-5-3                */


    /* 9112 - plain character expression used with non-permitted operator */
    -e9112
    -elib(9112)
    -append(9112,[MISRA C++ Rule 4-5-3])
	
	
/*  MISRA C++ Rule 5-0-2                */


    /* 9113 - dependence placed on C++ operator precedence */
    -e9113
    -elib(9113)
    -append(9113,[MISRA C++ Rule 5-0-2])
	
	
/*  MISRA C++ Rule 5-0-3                */


    /* 9114 - implicit conversion of integer cvalue expression */
    -e9114
    -elib(9114)
    -append(9114,[MISRA C++ Rule 5-0-3])

    /* 9116 - implicit conversion of floating point cvalue expression */
    -e9116
    -elib(9116)
    -append(9116,[MISRA C++ Rule 5-0-3])
	
	
/*  MISRA C++ Rule 5-0-4                */


    /* 9117 - implicit conversion changes signedness */
    -e9117
    -elib(9117)
    -append(9117,[MISRA C++ Rule 5-0-4])
	
	
/*  MISRA C++ Rule 5-0-5                */


    /* 9115 - implicit conversion from integer to floating point type */
    -e9115
    -elib(9115)
    -append(9115,[MISRA C++ Rule 5-0-5])

    /* 9118 - implicit conversion from floating point to integer type */
    -e9118
    -elib(9118)
    -append(9118,[MISRA C++ Rule 5-0-5])



/*  MISRA C++ Rule 5-0-6                */


    /* 9119 - implicit conversion of integer to smaller type */
    -e9119
    -elib(9119)
    -append(9119,[MISRA C++ Rule 5-0-6])

    /* 9120 - implicit conversion of floating point to smaller type */
    -e9120
    -elib(9120)
    -append(9120,[MISRA C++ Rule 5-0-6])



/*  MISRA C++ Rule 5-0-7                */


    /* 9121 - cast of cvalue expression from integer to floating point type */
    -e9121
    -elib(9121)
    -append(9121,[MISRA C++ Rule 5-0-7])

    /* 9122 - cast of cvalue expression from floating point to integer type */
    -e9122
    -elib(9122)
    -append(9122,[MISRA C++ Rule 5-0-7])
	
	
/*  MISRA C++ Rule 5-0-8                */


    /* 9123 - cast of integer cvalue expression to larger type */
    -e9123
    -elib(9123)
    -append(9123,[MISRA C++ Rule 5-0-8])

    /* 9124 - cast of floating point cvalue expression to larger type */
    -e9124
    -elib(9124)
    -append(9124,[MISRA C++ Rule 5-0-8])
	
	
/*  MISRA C++ Rule 5-0-9                */


    /* 9125 - cast of integer cvalue expression changes signedness */
    -e9125
    -elib(9125)
    -append(9125,[MISRA C++ Rule 5-0-9])


/*  MISRA C++ Rule 5-0-10               */

    /* 9126 - result of operator applied to underlying type must be cast */
    -e9126
    -elib(9126)
    -append(9126,[MISRA C++ Rule 5-0-10])

/*  MISRA C++ Rule 5-0-11               */

    /* 9128 - plain char type mixed with type other than plain char */
    -e9128
    -elib(9128)
    -append(9128,[MISRA C++ Rule 5-0-11])

/* Rule 5-0-12    (req) *********************************/

    /* Not currently supported */

/*  MISRA C++ Rule 5-0-13               */

    /* 909 - implicit boolean conversion from type 'Type' */
    -e909
    -elib(909)
    -append(909,[MISRA C++ Rule 5-0-13])

/*  MISRA C++ Rule 5-0-14               */

    /* 909 - implicit boolean conversion from type 'Type' */
    -e909
    -elib(909)
    -append(909,[MISRA C++ Rule 5-0-14])

/*  MISRA C++ Rule 5-0-15               */

    /* 947 - pointer subtraction */
    -e947
    -elib(947)
    -append(947,[MISRA C++ Rule 5-0-15])

    /* 9016 - performing pointer arithmetic via addition/subtraction */
    -e9016
    -elib(9016)
    -append(9016,[MISRA C++ Rule 5-0-15])

/*  MISRA C++ Rule 5-0-19               */


    /* 9025 - more than two levels of pointer indirection */
    -e9025
    -elib(9025)
    -append(9025,[MISRA C++ Rule 5-0-19])

/*  MISRA C++ Rule 5-0-20               */

    /* 9172 - bitwise operator 'Operator' used with non-const operands of
              differing underlying types */
    -e9172
    -elib(9172)
    -append(9172,[MISRA C++ Rule 5-0-20])

/*  MISRA C++ Rule 5-0-21               */

    /* 9130 - bitwise operator applied to signed underlying type */
    -e9130
    -elib(9130)
    -append(9130,[MISRA C++ Rule 5-0-21])


/*  MISRA C++ Rule 5-2-1                */

    /* 9131 - left/right side of logical operator is not a postfix expression */
    -e9131
    -elib(9131)
    -append(9131,[MISRA C++ Rule 5-2-1])

/*  MISRA C++ Rule 5-2-2                */

    /* 1774 - only dynamic_cast can indicate a failure by returning null */
    -e1774
    -elib(1774)
    -append(1774,[MISRA C++ Rule 5-2-2])

    /* 1939 - casting from base class to derived class */
    -e1939
    -elib(1939)
    -append(1939,[MISRA C++ Rule 5-2-2])

/*  MISRA C++ Rule 5-2-3                */

    /* 9171 - downcast of polymorphic type 'Type' to type 'Type' */
    -e9171
    -elib(9171)
    -append(9171,[MISRA C++ Rule 5-2-3])

/*  MISRA C++ Rule 5-2-4                */

    /* 1924 - use of c-style cast */
    -e1924
    -elib(1924)
    -append(1924,[MISRA C++ Rule 5-2-4])

    /* 1946 - use of functional cast */
    -e1946
    -elib(1946)
    -append(1946,[MISRA C++ Rule 5-2-4])


/*  MISRA C++ Rule 5-2-5                */

    /* 9005 - cast drops qualifier */
    -e9005
    -elib(9005)
    -append(9005,[MISRA C++ Rule 5-2-5])

/*  MISRA C++ Rule 5-2-7                */

    -e9176
    -elib(9176)
    -append(9176,[MISRA C++ Rule 5-2-7])

/*  MISRA C++ Rule 5-2-8                */

    /* 9010 - conversion from integer to pointer */
    -e9010
    -elib(9010)
    -append(9010,[MISRA C++ Rule 5-2-8])

    /* 9079 - conversion from pointer to void to pointer */
    -e9079
    -elib(9079)
    -append(9079,[MISRA C++ Rule 5-2-8])

/*  MISRA C++ Rule 5-2-9                */

    /* 9091 - cast from pointer to integer type */
    -e9091
    -elib(9091)
    -append(9091,[MISRA C++ Rule 5-2-9])

/*  MISRA C++ Rule 5-2-10               */

    /* 9049 - increment/decrement operation combined with other operation with
              side-effects */
    -e9049
    -elib(9049)
    -append(9049,[MISRA C++ Rule 5-2-10])

/*  MISRA C++ Rule 5-2-12               */

    /* 9132 - array type passed to function expecting a pointer */
    -e9132
    -elib(9132)
    -append(9132,[MISRA C++ Rule 5-2-12])	

/*  MISRA C++ Rule 5-3-1                */

    /* 9133 - boolean expression required for operator 'Operator' */
    -e9133
    -elib(9133)
    -append(9133,[MISRA C++ Rule 5-3-1])


/*  MISRA C++ Rule 5-8-1                */

    /* 9136 - the shift value is at least the precision of the MISRA C++
              underlying type of the left hand side */
    -e9136
    -elib(9136)
    -append(9136,[MISRA C++ Rule 5-8-1])

/*  MISRA C++ Rule 5-18-1               */

    /* 9008 - comma operator used */
    -e9008
    -elib(9008)
    -append(9008,[MISRA C++ Rule 5-18-1])


/*  MISRA C++ Rule 6-2-3                */

    /* 9138 - null statement not on line by itself */
    -e9138
    -elib(9138)
    -append(9138,[MISRA C++ Rule 6-2-3])



/*  MISRA C++ Rule 6-3-1                */

    /* 9012 - body should be a compound statement */
    -e9012
    -elib(9012)
    -append(9012,[MISRA C++ Rule 6-3-1])

/*  MISRA C++ Rule 6-4-1                */

    /* 9012 - body should be a compound statement */
    -e9012
    -elib(9012)
    -append(9012,[MISRA C++ Rule 6-4-1])

/*  MISRA C++ Rule 6-4-2                */

    /* 9013 - no 'else' at end of 'if ... else if' chain */
    -e9013
    -elib(9013)
    -append(9013,[MISRA C++ Rule 6-4-2])

/*  MISRA C++ Rule 6-4-3                */

    /* 9042 - departure from MISRA switch syntax */
    -e9042
    -elib(9042)
    -append(9042,[MISRA C++ Rule 6-4-3])

/*  MISRA C++ Rule 6-4-5                */

    /* 9090 - switch case lacks unconditional break or throw */
    -e9090
    -elib(9090)
    -append(9090,[MISRA C++ Rule 6-4-5])

/*  MISRA C++ Rule 6-4-6                */

    /* 744 - switch statement has no default */
    -e744
    -elib(744)
    -append(744,[MISRA C++ Rule 6-4-6])

    /* 787 - enum constant not used within switch */
    -e787
    -elib(787)
    -append(787,[MISRA C++ Rule 6-4-6])

    /* 9139 - case label follows default in switch statement */
    -e9139
    -elib(9139)
    -append(9139,[MISRA C++ Rule 6-4-6])


/*  MISRA C++ Rule 6-6-3                */

    /* 9254 - continue statement encountered */
    -e9254
    -elib(9254)
    -append(9254,[MISRA C++ Rule 6-6-3])

/*  MISRA C++ Rule 6-6-4                */

    /* 9011 - multiple loop exits */
    -e9011
    -elib(9011)
    -append(9011,[MISRA C++ Rule 6-6-4])

/*  MISRA C++ Rule 6-6-5                */

    /* 904 - return statement before end of function */
    -e904
    -elib(904)
    -append(904,[MISRA C++ Rule 6-6-5])


/*  MISRA C++ Rule 7-1-1                */


    -e843   /* static storage duration variable could be const */
    -elib(843)
    -append(843,[MISRA C++ Rule 7-1-1])

    -e952   /* parameter of function could be const */
    -elib(952)
    -append(952,[MISRA C++ Rule 7-1-1])

    -e953   /* local variable could be const */
    -elib(953)
    -append(953,[MISRA C++ Rule 7-1-1])
	
	
/*  MISRA C++ Rule 7-1-2                */

    /* 818 - parameter of function could be pointer to const */
    -e818
    -elib(818)
    -append(818,[MISRA C++ Rule 7-1-2])

    /* 1764 - reference parameter could be reference to const */
    -e1764
    -elib(1764)
    -append(1764,[MISRA C++ Rule 7-1-2])

    -fcv /* report parameters even if exclusively cast to void */
	
	
/*  MISRA C++ Rule 7-3-1                */


    /* 9141 - global declaration of symbol */
    -e9141
    -elib(9141)
    -append(9141,[MISRA C++ Rule 7-3-1])

    /* 9162 - use of static_assert/using declaration at global scope */
    -e9162
    -elib(9162)
    -append(9162,[MISRA C++ Rule 7-3-1])
	
	
/*  MISRA C++ Rule 7-3-3                */


    /* 1751 - anonymous namespace declared in a header file */
    -e1751
    -elib(1751)
    -append(1751,[MISRA C++ Rule 7-3-3])
	
	
/*  MISRA C++ Rule 7-3-4                */


    /* 9144 - using directive used */
    -e9144
    -elib(9144)
    -append(9144,[MISRA C++ Rule 7-3-4])
	
	
/*  MISRA C++ Rule 7-3-6                */


    /* 9145 - using declaration/directive in header */
    -e9145
    -elib(9145)
    -append(9145,[MISRA C++ Rule 7-3-6])



/*  MISRA C++ Rule 8-0-1                */


    /* 9146 - multiple declarators in a declaration */
    -e9146
    -elib(9146)
    -append(9146,[MISRA C++ Rule 8-0-1])
	
	
/*  MISRA C++ Rule 8-3-1                */


    /* 1735 - parameter of virtual function has default argument */
    -e1735
    -elib(1735)
    -append(1735,[MISRA C++ Rule 8-3-1])
	
	

/*  MISRA C++ Rule 8-4-1                */

    /* 9165 - function defined with a variable number of arguments */
    -e9165
    -elib(9165)
    -append(9165,[MISRA C++ Rule 8-4-1])

/*  MISRA C++ Rule 8-4-2                */

    /* 9072 - parameter of function has different name than previous
              declaration */
    -e9072
    -elib(9072)
    -append(9072,[MISRA C++ Rule 8-4-2])

    /* 9272 - parameter of function has different name than overridden
              function */
    -e9272
    -elib(9272)
    -append(9272,[MISRA C++ Rule 8-4-2])

/*  MISRA C++ Rule 8-4-4                */

    /* 9147 - implicit function-to-pointer decay */
    -e9147
    -elib(9147)
    -append(9147,[MISRA C++ Rule 8-4-4])

/*  MISRA C++ Rule 8-5-3                */

    /* 9148 - '=' should initialize either all enum members or only the first */
    -e9148
    -elib(9148)
    -append(9148,[MISRA C++ Rule 8-5-3])



/*  MISRA C++ Rule 9-3-1                */

    /* 605 - pointee implicitly gains/loses qualifier in conversion */
    -e605
    -elib(605)
    -append(605,[MISRA C++ Rule 9-3-1])

    /* 1536 - member function symbol exposes lower access member symbol */
    -e1536
    -elib(1536)
    -append(1536,[MISRA C++ Rule 9-3-1])

/*  MISRA C++ Rule 9-3-2                */

    /* 1536 - member function symbol exposes lower access member symbol */
    -e1536
    -elib(1536)
    -append(1536,[MISRA C++ Rule 9-3-2])

/*  MISRA C++ Rule 9-3-3                */

    /* 1762 - member function could be made const */
    -e1762
    -elib(1762)
    -append(1762,[MISRA C++ Rule 9-3-3])

/*  MISRA C++ Rule 9-5-1                */

    /* 9018 - union declared */
    -e9018
    -elib(9018)
    -append(9018,[MISRA C++ Rule 9-5-1])

/*  MISRA C++ Rule 10-3-2               */

    /* 1909 - virtual' assumed */
    -e1909
    -elib(1909)
    -append(1909,[MISRA C++ Rule 10-3-2])


/*  MISRA C++ Rule 10-3-3               */

    /* 9170 - pure function 'Symbol' overrides non-pure function 'Symbol' */
    -e9170
    -elib(9170)
    -append(9170,[MISRA C++ Rule 10-3-3])



/*  MISRA C++ Rule 11-0-1               */


    /* 9150 - non-private data member within a non-POD structure */
    -e9150
    -elib(9150)
    -append(9150,[MISRA C++ Rule 11-0-1])
	
	
/*  MISRA C++ Rule 12-1-2               */

    /* 1928 - base class absent from initializer list for constructor */
    -e1928
    -elib(1928)
    -append(1928,[MISRA C++ Rule 12-1-2])




/*  MISRA C++ Rule 12-1-3               */


    /* 9169 - constructor 'Symbol' can be used for implicit conversions to
       fundamental type 'Type' */
    -e9169
    -elib(9169)
    -append(9169,[MISRA C++ Rule 12-1-3])
	
	
/*  MISRA C++ Rule 12-8-1               */

    /* 1938 - constructor accesses global data */
    -e1938
    -elib(1938)
    -append(1938,[MISRA C++ Rule 12-8-1])



/*  MISRA C++ Rule 14-5-3               */

    /* 1721 - operator=() for is not a copy nor move assignment operator */
    -e1721
    -elib(1721)
    -append(1721,[MISRA C++ Rule 14-5-3])


/*  MISRA C++ Rule 14-7-3               */

    /* 1576 - explicit specialization is not in the same file as specialized
              function template */
    -e1576
    -elib(1576)
    -append(1576,[MISRA C++ Rule 14-7-3])




/*  MISRA C++ Rule 14-8-2               */

    /* 9153 - viable set contains both function and template */
    -e9153
    -elib(9153)
    -append(9153,[MISRA C++ Rule 14-8-2])


/*  MISRA C++ Rule 16-0-2               */

    /* 9158 - #define used within block scope */
    -e9158
    -elib(9158)
    -append(9158,[MISRA C++ Rule 16-0-2])

    /* 9159 - #undef used within block scope */
    -e9159
    -elib(9159)
    -append(9159,[MISRA C++ Rule 16-0-2])


/*  MISRA C++ Rule 16-0-3               */

    /* 9021 - use of '#undef' is discouraged */
    -e9021
    -elib(9021)
    -append(9021,[MISRA C++ Rule 16-0-3])



/*  MISRA C++ Rule 16-0-4               */

    /* 9026 - function-like macro defined */
    -e9026
    -elib(9026)
    -append(9026,[MISRA C++ Rule 16-0-4])



/*  MISRA C++ Rule 16-0-6               */

    /* 9022 - unparenthesized macro parameter in definition of macro */
    -e9022
    -elib(9022)
    -append(9022,[MISRA C++ Rule 16-0-6])



/*  MISRA C++ Rule 16-0-7               */

    /* 553 - undefined preprocessor variable assumed to be 0 */
    -e553
    -elib(553)
    -append(553,[MISRA C++ Rule 16-0-7])

/*  MISRA C++ Rule 16-0-8               */

    /* 16 - unknown preprocessor directive */
    -e16
    -elib(16)
    -append(16,[MISRA C++ Rule 16-0-8])

    /* 544 - preprocessor directive not followed by EOL */
    -e544
    -elib(544)
    -append(544,[MISRA C++ Rule 16-0-8])

    /* 9160 - unknown preprocessor directive in conditionally excluded region */
    -e9160
    -elib(9160)
    -append(9160,[MISRA C++ Rule 16-0-8])

/*  MISRA C++ Rule 16-2-3               */


    /* 967 - header file does not have a standard include guard */
    -e967
    -elib(967)
    -append(967,[MISRA C++ Rule 16-2-3])

/*  MISRA C++ Rule 16-2-4               */

    /* 9020 - header file name with non-standard character */
    -e9020
    -estring(9020,\)    /* not covered by this rule */
    -append(9020,[MISRA C++ Rule 16-2-4])

/*  MISRA C++ Rule 16-2-5               */

    /* 9020 - header file name with non-standard character */
    /*  Note: If your system requires the '\' be used as a directory
        separator, comment out the following options.  */
    -estring(9020,\)
    -append(9020(\),[MISRA C++ Rule 16-2-5])



/*  MISRA C++ Rule 16-3-1               */

    /* 9023 - multiple use of stringize/pasting operators in definition of macro */
    -e9023
    -elib(9023)
    -append(9023,[MISRA C++ Rule 16-3-1])


/*  MISRA C++ Rule 16-3-2               */

    /* 9024 - pasting/stringize operator used in definition of macro */
    -e9024
    -elib(9024)
    -append(9024,[MISRA C++ Rule 16-3-2])


/*  MISRA C++ Rule 17-0-1               */


    /* 9052 - macro defined with the same name as a C++ keyword */
    -e9052
    -elib(9052)
    -append(9052,[MISRA C++ Rule 17-0-1])

    /* 9071 - defined macro is reserved to the compiler */
    -e9071
    -elib(9071)
    -append(9071,[MISRA C++ Rule 17-0-1])
	
/*  MISRA C++ Rule 17-0-2               */


    /* 9093 - the name is reserved to the compiler */
    -e9093
    -elib(9093)
    -append(9093,[MISRA C++ Rule 17-0-2])
	
	
/*  MISRA C++ Rule 18-0-1               */

    /* 829 - a +headerwarn option was previously issued for header */
    -e829
    -elib(829)
    +headerwarn(time.h)
    +headerwarn(limits.h)
    +headerwarn(float.h)
    +headerwarn(stddef.h)
    +headerwarn(errno.h)
    +headerwarn(locale.h)
    +headerwarn(stdio.h)
    +headerwarn(ctype.h)
    +headerwarn(string.h)
    +headerwarn(math.h)
    +headerwarn(stdlib.h)
    +headerwarn(assert.h)
    +headerwarn(stdarg.h)
    +headerwarn(setjmp.h)
    +headerwarn(signal.h)
    -append(829,[MISRA C++ Rule 18-0-1])
	
/*  MISRA C++ Rule 18-0-4               */

    /* 829 - a +headerwarn option was previously issued for header */
    -e829
    -elib(829)
    +headerwarn(ctime)
    -append(829,[MISRA C++ Rule 18-0-4])
	
	
/*  MISRA C++ Rule 18-4-1               */


    /* 9173 - use of non-placement allocation function 'Symbol' */
    -e9173
    -elib(9173)
    -append(9173,[MISRA C++ Rule 18-4-1])

    /* 586 - 'String' 'Name' is deprecated */
    -e586
    -elib(586)
    -deprecate( function, calloc, [MISRA C++ Rule 18-4-1] )
    -deprecate( function, malloc, [MISRA C++ Rule 18-4-1] )
    -deprecate( function, realloc, [MISRA C++ Rule 18-4-1] )
    -deprecate( function, free, [MISRA C++ Rule 18-4-1] )



/*  MISRA C++ Rule 18-7-1               */

    /* 829 - a +headerwarn option was previously issued for header */
    -e829
    -elib(829)
    +headerwarn(csignal)
    -append(829,[MISRA C++ Rule 18-7-1])
	
/*  MISRA C++ Rule 27-0-1               */



    /* 829 - a +headerwarn option was previously issued for header */
    -e829
    -elib(829)
    +headerwarn(cstdio)
    -append(829,[MISRA C++ Rule 27-0-1])
    
+libdir(/usr/include/c++/8)
+libdir(/usr/include/x86_64-linux-gnu/c++/8)
+libdir(/usr/include/c++/8/backward)
+libdir(/usr/lib/gcc/x86_64-linux-gnu/8/include)
+libdir(/usr/local/include)
+libdir(/usr/lib/gcc/x86_64-linux-gnu/8/include-fixed)
+libdir(/usr/include/x86_64-linux-gnu)
+libdir(/usr/include)

-wlib(1)
-std=c++11
